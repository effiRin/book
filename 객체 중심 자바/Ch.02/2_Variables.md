# CHAPTER 2. 변수

## 변수

- 데이터를 담아두는 상자 / 그 데이터를 나타내는 일종의 기호 or 지시 대명사
- 앞으로 내용이 변할지도 모르는 문자, 숫자, 자료구조 등의 데이터
- 프로그램을 구성하는 요소는 크게 두 가지 : ‘처리할 데이터’ / ‘그 데이터를 핸들링하는 로직’

```
int v1 = 10 ;  // v1이란 변수에 리터럴(literals, 상수) 10이란 값을 담는다.
               // 정확히는 ‘메모리상에 있는 어떤 데이터를 가리킨다’고 표현
```
<br>

### 데이터를 변수를 이용해서 선언하는 이유
1. 필요한 데이터를 나중에 한 번에 수정하기 위해서
2. 어떤 데이터인지 나타내기 위해서

- 반드시 변수의 자료형(Type)을 먼저 선언한다.
- java는 반드시 변수의 타입에 맞는 데이터만 표현할 수 있다. (C, C++ 도 비슷) -> 엄격한 언어
<br>

### 변수 작성 가이드
1. 변수의 이름은 의미를 알아볼 수 있는 이름으로 한다. (예 : userid, userPw, grade)
2. 변수의 이름은 소문자로 시작
3. 단어와 단어를 이어서 의미를 줄 때는 ‘_’ 또는 연결되는 단어 첫 글자를 대문자로 표시  
(예 : totalCount, sum_result, xPosition, salePrice)
<br>

### Java에서 변수의 종류 : 기본 자료형 vs 객체 자료형

- 기본 자료형(Primitive Type) : 프로그래밍 언어에서 미리 만들어 둔 타입 (가장 많이 쓰이는 데이터 쉽게 사용 위함)
- 객체 자료형 : 단순 데이터x / 복합적인 데이터를 의미 / C언어에선 ‘포인터 변수’ / Java에서는 ‘레퍼런스’라는 용어 사용  
- 기본 자료형은 단순 데이터를 담는 상자 / 객체 자료형은 덩치가 큰 데이터를 담을 때 사용
<br>

### 기본 자료형

- Java에서 변수 선언 규칙(Naming Convention)
- Java는 대, 소문자를 구분한다.
- 문자, ‘_’, ‘$’로 변수 이름 시작 가능
- 숫자로 변수 이름 시작 불가능!
- 지정된 단어는 사용 불가능
<br>

### 기본 자료형에서 가장 많이 쓰이는 타입

- ‘정수’ 표현할 땐 int
- ‘소수’ 표현할 땐 double
- 참, 거짓(불 타입)인 경우엔 boolean (true 또는 false)
- 글자 하나를 의미할 땐 char (작은 따옴표로 문자값 주기)
```
int i = 100;
double d = 10.5555;
boolean b = true;
char c = ‘가’;
```
<br>

### 기본 자료형 변수 선언
1. 데이터 타입 변수명 = 값 ;  
예) int value = 10;  
<br>

2. =는 할당(Assign) 연산자
- ‘=’ 의 왼쪽은 대상 상자 / 오른쪽은 상자의 내용물
- ‘=‘의 왼쪽은 데이터를 넣으려는 대상 / 오른쪽은 꺼낼 데이터를 의미 <br>
예) 	int j = i ;	// j 상자에 i의 내용물을 꺼낸다.  

- Java에서 ‘a = b’는 b 상자의 내용물을 a 상자로 복사한다는 뜻 <br>
```
int i = 10 ;	// i라는 상자를 만들고 10값을 넣는다. <br>
int j = i ; 		// j라는 상자를 우선 만들고, i의 내용물을 꺼내 복사해서 j에 담는다.
```
<br>

3. = 뒤에 데이터를 줘도 되고, 안 줘도 됨.
- 메모리상에 상자만 만들어 두거나	(예) int i ;
- 상자를 만들면서 데이터도 같이 넣어주거나	(예) int i = 10; <br>
(이 경우, ‘선언과 동시에 변수를 초기화한다’고 표현한다)
<br>

4. 앞서 선언된 변수는 다시 타입을 붙이지 않는다.
예) int i = 10 ; <br>
int j = i ; <br>
i = 100 ; // j의 값은 10, i의 값은 100  
<br>

### 기본 자료형 : byte, short, int, long <br>
: 변수의 타입에 따라서 메모리를 차지하는 공간의 크기(상자의 크기)가 달라진다.  
<(적절한 메모리 공간 할당을 위한 다양한 타입)  
<br>

#### bit와 byte의 관계 - 2진수
- 예) ‘byte b = 10’
- byte b를 선언하면, 메모리에 1byte(8bit)의 공간을 만들어 낸다. 즉, 8개의 bit가 모인 공간에 0으로 데이터가 채워짐.
때문에 기본 자료형의 경우, 변수에 값을 주지 않아도 기본값을 가지게 된다.
- 2진수 변환법 : 2의 몇 제곱인지만 알면 된다.  
<br>

#### long 타입
- long 타입은 정말 큰 숫자를 표현할 때만 사용
- 정수를 나타내는 데 있어서 가장 큰 자료형은 long (2의 64승까지의 숫자 표현 가능)  
<br>

#### 소수를 나타내는 float, double
- 데이터 뒤에 d/D 혹은 f/F를 붙여서 명확히 해주기
```
double d = 3.14D;
float f = 1.23F;
```  
<br>

- 만일 아무것도 없는 소수 데이터를 선언하면 double 타입으로 간주.
```
float f = 10.0F;
double d = 1.2345;
```  
<br>

- 소수점 이하의 숫자를 표현하기 위해서 다음 두 가지를 사용  
float : 4byte 소수를 표현  
double : 8byte 소수를 표현 (기본)  
<br>

- 소수는 32bit(4byte)인 float가 아닌, 64bit(8byte)인 double 타입을 기본으로 사용한다.  
큰 메모리를 사용하는 기본적인 이유는 소수는 정밀한 연산을 처리하기 때문.  

- 소수는 데이터 저장 방식이 다르다. (IEEE 754)  
- bit에는 0과 1만 들어갈 수 있고, 각 bit 안에 들어간 숫자는 2의 n승과 결합해서 표현된다.  
그런데 곰곰이 생각하면, bit 안에 들어가는 데이터로는 소수점을 표현할 수 없다는 사실을 알 수 있다.  
2의 0승부터 시작해도 역시 정수이기 때문.  
- 따라서, double과 float의 경우는 데이터를 저장하기 위해서 특별한 방식으로 데이터를 저장한다.  
- Java의 소수점 연산은 ‘IEEE 754’라는 표준을 따라 연산된다.  
<br>

#### ‘참, 거짓’을 나타내는 boolean
- Java에서 ‘참, 거짓’ 연산은 다른 언어들(C언어)과 달리 0/1을 사용하지 않고, 무조건 true/false라고만 표현.
- 상황에 따라서 다르게 동작해야 할 필요가 있는 ‘제어문’ 같은 곳에 많이 사용
- 변수 그 자체의 선언보다, 특정한 로직 제어 시 더 많이 사용
- 예) 홀, 짝수 구분 / 데이터 값의 검증이 성공했는지 여부 (로그인)  
<br>

#### 글자(문자) 하나를 나타내는 char
- char은 알파벳 글자 하나, 한글 문자 하나를 의미한다고 생각.
- char를 이용할 때는 작은따옴표(‘)를 이용해서 표시 / 2byte로 데이터를 표현  
- 한,중,일 문자들은 하나의 byte에 글자를 표현하기 부족해서 2byte 이상의 공간에 글자를 표현한다.  
<br>

## 변수 선언 가이드  
<br>

### 요약
- 매번 다른 데이터를 사용할 때
- 연산한 결과를 보관할 때
- 한 번 선언한 데이터를 여러 곳에서 사용할 때
- 결론 : 변수는 하나의 데이터를 여러 곳에서 사용하다가 쉽게 변경할 수 있게 하기 위해 선언하고 사용한다.  
<br>

## 형 변환(Type Conversion) : 어떤 데이터를 다른 타입의 데이터로 취급하는 방법  
- 형 변환의 경우
1. 하나의 데이터를 크기가 작거나 큰 상자로 복사할 때
int a = 10;
long b = a;

2. 특정 타입의 데이터를 다른 타입의 데이터로 사용할 때
char = ‘A’;
int i = c;  
<br>

### 자동(묵시적)형 변환 / 명시적 형 변환  

#### 1. 자동 형 변환
- 별도의 작업을 하지 않아도 알아서 처리된다. (JVM 내에서 알아서 해석되는 변환 작업)
```
byte b = 10;
int i = b;
// 변수 i의 크기가 더 커서 데이터 손실 없이, 아무런 제약 없이 옮길 수 있다.
```

- 자료형이 다른 데이터
```
char c = ‘A’ ;
int j = c;
// 결과 : 65
```
c라는 이름의 변수는 알파벳 문자 ‘A’를 담고 있고, 밑의 라인에서 j라는 숫자 타입의 변수가 c를 담고 있다.
char 은 2byte의 상자, int는 4byte의 상자이므로 작은 상자 c를 큰 상자 j에 넣을 수 있게 된다.
그러나 int 이므로 A라는 글자에 대한 ASCII 코드 값으로 결과가 출력된다.
(마찬가지로 새로 담는 변수가 큰 상자이기 때문에, 원래의 값은 그대로 유지되며 별도의 작업이 필요하지 않다.)  
<br>

#### 참고 : ASCII (American Standard Code for Information Interchange - 미국 정보 교환 표준 부호)
- 영문 알파벳을 사용하는 대표적인 문자 인코딩 (대부분의 문자 인코딩이 아스키에 기반을 둔다)
- 아스키는 7비트 인코딩으로, 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어진다. (제어 문자들은 역사적 이유로 남아 있으며, 대부분은 더 이상 사용되지 않는다)
- 출력 가능한 문자들은 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수문자, 그리고 하나의 공백 문자로 이루어진다.
- 다양한 아스키 기반의 확장 인코딩들이 등장했으며, 이들을 묶어서 아스키라고 한다.  
<br>

#### 2. 명시적 형 변환 : Casting
- 큰 범위의 타입에서 작은 범위의 타입으로 옮기는 작업으로, 데이터 손실이 우려됨.
따라서 개발자가 이 사실을 정확히 알 수 있도록 컴파일 시에 알려준다.  

```
int x = 1;
byte y = x;
// x는 int 타입의 변수 (4byte), y는 byte 타입의 변수(1byte)
이 경우, y에 x의 모든 데이터를 온전하게 담을 수 없을 때가 생긴다.
```

- 해결책 : 명시적 형 변환  
```
int x = 1;
byte y = (byte) x;
// x 앞에 () 소괄호를 이용해서 byte만큼의 상자로 줄이는 것
```

- 명시적 형 변환은 ‘데이터가 잘릴 수 있다’  
```
int xx = 128;
byte yy = (byte) xx;
System.out.println(yy);
// 결과 : -128 (데이터가 변질됨)
```

int 타입으로 만들어진 변수 xx는 128이란 값을 정상적으로 저장하고 있다.
다음 라인에서 yy는 byte로 더 작은 크기의 상자이므로, (byte) xx로 줄여낸 다음 처리하고 있다.
문법적으로 위 코드는 전혀 문제가 없으나, 문제는 ‘변질된 값’임.


```
int xx = 257;
byte yy = (byte) xx;
System.out.println(yy) ;
// 출력 결과 : 1 (8개의 bit만 끊어서 구성하면 남은 데이터는 1밖에 없음)
```

다운 캐스팅(Down Casting)은 큰 상자에서 작은 상자로 데이터를 옮길 때 필요한 크기로 잘라낸다는 개념.  
잘라내게 되면 원하지 않는 데이터가 들어갈 수 있는데, 데이터가 부분부분 잘려나가면서 캐스팅되기 때문. 
<br>

- 정리
큰 범위 타입(long이나 double)의 변수를 작은 범위 타입의 변수로 처리하게 되면 원래의 bit 공간 안에 들어 있는 데이터를 잃어버릴 수 있다.  
따라서 개발자가 반드시 이 상황을 알 수 있도록 ( )를 이용해서 처리해야 한다.  
<br>

#### 상자의 크기가 같더라도 변수의 타입이 다른 경우  
- 상자의 크기(몇 바이트인지)가 같다면 다음으로 고려할 것은 ‘상자의 유형’  
- 같은 크기의 상자여도 타입이 완전히 달라진다면 ‘캐스팅’ 작업이 필요하다.  

```
char c1 = ‘A’;
short s1 = c1; 
// 컴파일 불가 -> char와 short 타입 모두 2byte의 크기 상자지만, 타입이 달라 캐스팅 필요
```
따라서, 원래의 데이터가 다른 타입으로 변하면서 개발자가 의도하지 않았던 데이터의 변화가 있을지도 모를 때에는 ‘명시적인 형 변환’을 해야 한다.
<br>

#### 소수(double, float)는 주의
```
long lval = 1234.L; // (8byte)
float favl = lval; // (4byte)
```
- 배운 이론에 따르면 위 선언은 잘못된 것으로 컴파일할 수 없는 코드다. 하지만, 실제로 위의 코드는 전혀 문제가 없는 코드.  
- 큰 상자의 내용물을 작은 상자에 넣는데 아무런 조치를 하지 않아도 문제가 없는 이유는, 소수일 때는 데이터를 보관하는 데 있어서 일종의 연산 작업이 이루어지기 때문.
- double, float는 데이터를 ‘000000’과 같은 방식으로 표현하는 것이 아니라, 연산의 결과로 ‘부호+지수+가수’의 형태가 되므로, 일반적인 형 변환의 법칙에서는 조금 예외
<br>

#### 자료형이 바뀌는 경우 : 정수와 소수의 연산은 소수
소수를 나타내는 double과 float를 사용하는 경우에 값이 자동으로 바뀔 수 있는 상황이 빈번함.

```
int x = 10;
int y = 3;
System.out.println(x/y)
// 결과 : 3
정수와 정수의 연산은 무조건 정수로 연산된다.
```

```
int x = 10;
double y = 3;
System.out.println(x/y);
// 결과 : 3.333333333335
‘정수와 소수의 연산은 소수로 자동 변환된다’ 
```
<br>

## 화면에 숫자 입력받기

- Scanner 사용 방법
1. 소스의 맨 위에 ‘import java.util.*;’ 구문 추가하기  
Scanner 등의 특별한 기능을 모아둔 것을 이 소스에 사용한다는 의미. (전문적으로 package라고 한다.)  

2. Scanner scanner = new Scanner([System.in](http://system.in/)) 구문 추가하기  
System.out.println(); 이 화면에 우리가 원하는 변수나 메시지를 출력하는 기능이라면 System.in은 반대로 입력(input)기능이다.  

3. scanner.nextInt(); 변수에 담아주기
사용자가 입력한 데이터를 처리하는 부분은 scanner.nextInt() 이다. nextInt()는 사용자가 입력한 문자를 숫자로 만들어 준다.

```
Scanner scanner = new Scanner ([System.in](http://system.in/));
System.out.println(“화면에 숫자를 입력해 주세요.”);
int input = scanner.nextInt();
System.out.println(“당신이 입력한 숫자는” + input);
```
<br>
