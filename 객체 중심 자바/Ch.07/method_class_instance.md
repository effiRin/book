# CHAPTER 7. 메소드, 클래스, 인스턴스

# 메소드

- **함수** : 로직, 기능을 하나의 { }로 묶어서 한 덩어리로 만드는 방식
java에선 이를 **Method**라고 한다

- **함수는 3가지 형태로 구성**된다.
1. 메소드(함수)는 반드시 **자신을 구분할 수 있는 이름**을 가진다.
2. 메소드(함수)는 **동작하는 데 있어서 필요한 데이터**를 가질 수 있다.
3. 메소드(함수)는 **필요하다면 결과를 반환해주는 기능**도 있어야 한다.

- **명명 규칙**
1. 동작, 기능, 로직 관련 일이라 영어 '동사' 사용
2. 단어와 단어 사이는 대문자. 첫 글자는 대문자. (Class 파일이므로)
예) SumMachine

- **메소드 실행 시 필요한 데이터 : '파라미터' ( = 인자, 인수)**

- **메소드 이용 방식 2가지**
1. **Static** 라는 키워드와 함께 작성되는 **진짜 함수**와 비슷한 방법
2. **클래스, 객체** 이용해서 **동작하는 객체** 만드는 방법

- **메소드 만들기**
1. 메소드는 우선 **‘public void 메소드이름() {} ‘**을 작성하고 생각한다.
- public은 ‘누구나 이 기능을 사용할 수 있게’
- void는 ‘메소드를 호출한 쪽에서 결과를 얻을 수 없다는 표현’
- { } 안에는 필요한 데이터를 넣어준다. 
(괄호 안에는 이 기능을 실행하기 위해서 필요한 input이 무엇인지 얘기해준다
예를 들어, 필요한 데이터가 숫자인지, 숫자 몇 개인지...)

1. **메소드는 만들었으면 무조건 실행되게 한다.**
코드의 작은 부분이라도 반드시 실행해서 결과를 확인하도록 한다. → ‘디버깅’

- **main 메소드는 객체지향 프로그램과 무관하다.**
main 메소드는 어떤 로직을 실행 순서대로 만드는 게 중요하다
반면, 객체지향은 로직보다 객체에 중점을 둔다.

- **메소드를 만들면...**
1. 재사용이 가능하다. (메소드만 호출하면 해당 코드를 다시 쓸 수 있음)
2. 메소드가 데이터 입력받게 하면(메소드의 parameter - 메소드의 input 값에 다른 값을 줄 수 있게 하는 것) 매번 다른 데이터 처리 가능하다.
-> 재사용하려면 매번 다른 값을 줄 수 있게 한다.

- **파라미터의 타입 지정하기**
public void MakeSum(int startVal, int endVal)
-> 입력받는 두 데이터 중 첫 번째 들어온 데이터는 startVal에,
두 번째 들어온 데이터는 endVal

- **메소드에 선언하는 변수는 그 안에서만! → '지역 변수(local variable)'**

- **메소드 실행 결과**

— 리턴 타입 : 메소드 실행 후 독점 타입 결과 반환 선언하는 것 
                      (로직이나 기능을 수행한 후 어떤 형태로 결과 데이터가 나올지 정해져 있어야 하니까) 

— 리턴값 : 결과 데이터 / 연산자와 달리 결과 데이터 받기를 선택할 수 있다.

— 리턴 타입 유형
**void** -> 메소드를 실행해도 결과 데이터를 반환 X
**void 외 다른 타입** -> 메소드를 실행하면 반드시 그 타입의 결과 데이터 반환 O

예) public int makeSum(int start, int end){   // int 타입의 데이터 피드백

— return 키워드 이용해서 데이터 반환
(return은 실행을 여기까지 한다는 의미)

- **메소드 구성요소 3가지 : 메소드 이름 / 파라미터 / 리턴 타입**

1) 만들려는 ‘메소드의 이름’을 결정한다.

2) 메소드 실행에 필수적인 파라미터를 결정한다.

3) 메소드 실행 후 즉각적으로 피드백을 받을 것인지 결정한다.

# 객체지향의 객체(Object)

- **객체**

— 데이터를 알아서 보관, 관리 → 따라서 코드 호출할 때 편리하다.

— '데이터 - 로직(메소드)'이 서로 유기적으로 묶인 구조가 '객체'다.

- **클래스 : 데이터와 로직을 묶어둔 하나의 데이터.**
데이터와 로직을 묶어둔 덕분에 누구나 동일한 기능 사용하게 하나,
때에 따라서 다른 데이터를 보관할 수 있게 한다.

- **클래스**는 **복사본을 만들기 위한 원형(prototype)**과 같다.
따라서 다음과 같은 특징을 가진다.

— 각자 따로 보관하고 싶어하는 데이터 혹은 속성들
— 데이터에 관계없이 제공되는 같은 기능, 로직

→ 그리고 클래스의 복제본을 **'객체(Object, instance)'**라고 한다.

- 데이터 보관을 위한 장치 → '변수'
**객체마다 보관하는 변수**라는 의미에서 **'인스턴스 변수'**라고 한다.

- **객체지향 프로그래밍 순서**
1. 만들고 싶은 존재(Object)를 만들어 내기 위한 틀(Class)를 먼저 작성
2. 틀(Class) 선언 후, 필요 시 복사본(Instance 혹은 Object) 만들어 각자 필요에 맞게 사용
    
    → **인스턴스 = 객체 = 클래스(틀)의 복제본**
    

- 코드 : PigSave save = new PigSave();
(그림 그리기)

PigSave save1 = new Pigsave();

PigSave save2 = new Pigsave();

→ 이런 식으로 객체 여러 개 만들 수 있다.

- **변수 스타일 2가지**

**기본자료형** : 변수에 데이터가 직접 담김

**객체자료형** : 변수에 리모콘이 담음

- ‘**배열’**과 ‘클래스에서 생산된 **객체**’의 공통점 → 둘다 **여러 개의 데이터를 가질 수 있는 구조**

- **기본형 자료는 기본값을 가진다.**

byte, short, int, long : 숫자이므로 0

double, float : 소수이지만 데이터 없으므로 0.0

char : 아스키코드에 따라 ‘ ‘ (공백문자)

boolean : false

(예) int a ; 

// 변수 선언만 하고 따로 데이터 안 넣음. 따라서 기본값은 0
(int는 4byte이므로 32bit 상자, 각 bit에 0이 들어간 모양)

- **null**
1. **객체 자료형 변수**의 상자에 내용물 없을 때 사용
2. **제어문**에서 변수에 리모콘이 실제 객체를 가리키는데 사용

(예) if (a == null) 연산

a는 객체 자료형이고, a 안의 리모콘이 가리키는 객체가 있는지 없는지 따질 때 사용

- **NullPointerException 에러**

예) PigSave save = new PigSave( );

save = null ;    // 리모콘이 객체 가리키지 않게 함
save.deposit( );    // 리모콘이 가리키는 실체가 없으므로 동작 X

→ **해결법** : 문제가 일어난 부분에서 **‘ . ’ (점 - 리모콘 누르는 동작)**을 찾고 이용되는 변수 확인하기

- **객체 (object) : 메소드 기능 + 데이터의 결합체**

— ‘클래스’를 통해 필요한 만큼 만들고

— 메소드를 통해 데이터 저장 / 메소드는 데이터를 이용해서 제어함

— **‘인스턴스 변수’ → 객체의 데이터** 
(클래스의 복사본인 객체가 각각 가지는 데이터를 의미
메소드를 통해서 실행된 데이터를 보관하는 역할)

# 인스턴스 변수

예) public class PigSave {
public int total;
// **클래스 {} 안쪽에 선언한 변수** -> 각 객체마다 가지는 독립적인 데이터
// 값을 주지 않고 선언만 하는 이유? -> 클래스에서 나온 객체마다 다른 값을 가질 수도 있기 때문
// 따라서 인스턴스 변수는 필요하지 않으면 값을 줄 필요 X
// **인스턴스 변수의 용도 : 메소드를 통해서 실행된 결과 데이터를 보관**
// -> deposit 메소드를 통해 입금하면 total 데이터에 누적된다.

- **인스턴스 변수는 객체의 리모컨(레퍼런스)으로 사용할 수 있다.**

— 객체의 리모컨(레퍼런스)를 이용해서 가장 많이 하는 작업은,
**객체의 메소드를 실행**하는 것과, **객체의 데이터(속성)에 접근**하는 작업

— java에서 어떤 변수에 객체의 리모컨을 담아 두었다면
그 **변수와 '.'의 접근 방식**을 이용해서 어떤 동작을 시킬 수 있다.

예)
Scanner scanner = new Scanner([System.in](http://system.in/));
int a = scanner.nextInt();

→ 이처럼 '.'(dot)은 java 프로그래밍에서 어디엔가 접근하거나 메소드를 실행할 때 사용하는데,
그 대상은 2가지 **‘객체가 가진 메소드 / 객체가 가진 데이터’**

→ 즉, 객체의 리모컨(레퍼런스)를 이용해서 객체의 데이터와 객체의 메소드를 사용할 수 있다.

(그림19)

→ save라는 변수 안에는 리모콘이 담겨있고,
리모콘은 pigsave 객체, total 금액 데이터, deposit()메소드, withdraw()메소드를 접근할 수 있다

```jsx
public static void main(String[] args) {
      PigSave save = new PigSave();   
// 변수 save에 클래스에서 생산된 객체의 리모콘(레퍼런스)을 담는다

        save.deposit(100);      
// 변수에 리모콘을 담아두었다면 변수와 '.'의 접근 방식을 통해 어떤 동작을 시킬 수 있다.

        save.deposit(500);      
// 객체에 있는 deposit 메소드 기능 실행

        System.out.println(save.total);  
// 마찬가지로, 변수와 '.'을 통해 객체의 데이터에 접근하여 출력
```

- **정보 은닉** : 객체의 데이터는 함부로 공개하지 않는다.

— '.'을 이용하면 객체가 가진 로직과 데이터에 마음대로 접근할 수 있어 편하게 사용할 것 같지만,
실제로는 절대 이렇게 프로그램을 작성하면 안 된다.

— 객체의 데이터를 마음대로 직접 접근할 수 있다면...
메소드를 통해서 만들어진 데이터는 의미가 없게 되는 문제 발생 
(total 데이터의 값을 사용자 마음대로 조작할 수 있게 되는 문제 발생하기 때문.)

예) save.total = 10000;
→ 원래 total 값은 600원이었지만 이런 식으로 값을 주면 total은 10000원이 되어버림

→ 즉, 입금이라는 메소드를 통해서만 금액 데이터가 변경 가능해야 한다.

→ 객체에서 데이터는 어떤 메소드의 실행 결과를 누적해서 보존하는 경우가 많기 때문에 함부로 누구나 사용할 수 있게 하면 안된다.

- **객체의 데이터는 메소드를 통해 변경해야 한다.**
객체가 가진 기능(메소드)을 통해 데이터를 조정한다.
객체가 가지는 데이터는 호출한 쪽에서 데이터를 보관하지 않도록 하기 위한 장치다.

- **데이터가 외부에 공개되면 데이터의 순수성을 보장할 수 없게 된다.**
즉 밖으로 한번 나갔다 왔던 데이터는 누군가 조작했을 가능성도 있게 된다.
그래서 객체지향 프로그래밍에서 데이터는 감추어 두고 사용해야 한다고 주장.
이것을 **'캡슐화', '정보 은닉'**이라는 용어로 말한다.

- **접근 제한자 (Access Modifier)** : 외부에서 데이터에 접근하는 것을 막는다.
(= 객체 안의 데이터는 외부에서 보이지 않게 한다.)

→ **private : 외부에 공개하지 않는다.**
객체가 가진 데이터 앞에 private라는 단어를 사용하여 코드를 수정.

**예)**

```jsx
public class PigSave {
private int total // public 에서 변경

public class PigSaveTest {
public static void main(String[] args) {
Pigsave save = new Pigsave();
save.deposit(100);
save.deposit(500);
System.out.println(save.total);  // 컴파일 에러가 뜬다.
```

→ Pigsave 클래스 내 total 변수 앞에 private를 붙여주면,
PigSaveTest클래스에선 직접 접근이 안되어 컴파일 에러가 발생한다.

→ 클래스를 작성할 때 **인스턴스 변수를 private으로 작성한다는 것은,**
**클래스의 { }를 벗어나서는 접근할 수 없게 한다**는 뜻
클래스 { }의 바깥쪽 코드에서는 private으로 선언된 인스턴스 변수를 사용할 수 없다.

- **그럼 객체가 가진 데이터는 어떻게 알아내는가?**

— **객체의 데이터는 특별한 경우가 아니라면, 모두 private로 처리**한다.
— 외부에서 필요하다면 메소드를 이용해서 알 수 있도록 하는데,
이런 메소드를 보통 ‘**getter 메소드’**라고 한다.

— **객체가 가진 데이터를 접근하는 메소드**는 **getXXX** 같은 이름을 가진다.

**예)** total 데이터를 알려주는 getTotal() 메소드를 추가한 PigSave

(= PigSave에서 getTotal()이라는 메소드를 통해서 객체가 가진 데이터를 가져오게 함)

```
public class PigSave {
private int total;
// 인스턴스 변수 total을 private로 선언,
// PigSaveTest 클래스에서 직접 접근 불가능, getter메소드 이용해야 함
// public int total;   -> public으로 선언하면 PigSaveTest 클래스에서도 직접 접근 가능

public int getTotal() {	// total 값을 반환하는 메소드이므로, 리턴타입은 int
	return total;	//
}

public void deposit(int amount) {
	System.out.println("저금통 입금");
	total = total + amount
}

public void withdraw() {
	System.out.println("저금통 배를 땁니다.");
	total = 0;
}

```

```
public class PigSaveTest {
public static void main(String[] args) {
PigSave save = new PigSave();
save.deposit(100);
save.deposit(500);

int totalMoney = save.getTotal();
    // getTotal 메소드를 호출하여 반환된 total값을 Copy해서 totalMoney에 넣는다.
    // total값을 복사한 totalMoney를 이용하기 때문에 원본은 안전함.

System.out.println("총액 : " + totalMoney);
}
}
```

- **변수에 접근하는 대신 굳이 get 메소드를 쓰는 이유**

→ return한 결과를 받는 작업은 또다시 '복사'입니다.

예) int totalMoney = save.getTotal(); // total 변수의 값을 totalMoney 변수로 복사
→ PigSave 객체엔 total 데이터와 getTotal() 메소드가 있다.
save.getTotal()을 호출하면 PigSave 객체는 자신이 가진 total 데이터를 반환한다.
변수 할당은 '복사(Copy)' 개념으로, 메소드의 결과물(total 데이터)을 복사해서 변수에 담는다.
→ 따라서, 데이터에 직접 접근하지 않고 데이터를 복사하기 때문에 원본은 안전하다.

- **객체의 데이터는 반드시 안전하게!**

— 객체가 데이터를 가질 수 있는데, 이 데이터는 메소드를 통해서 접근하도록 하고, 가능하면 외부에 공개하지 않는다.

— 객체지향에선 대부분 데이터를 객체로 만들어서 보관한다.
이런 객체 안에 보관하는 데이터는 안전하게 보관해야 하므로, 외부에서 사용할 수 없게 private 키워드를 이용해서 처리한다.

— 데이터를 얻는 메소드는 getXXX()로 만들어준다.
메소드를 통해서 데이터를 얻으면 원본 데이터가 안전하게 보관된다.
이런 메소드를 일반적인 getter라고 한다. (데이터를 get하는 기능)

— **메소드를 통해서 데이터를 변경한다면 setter**
데이터를 바꿀 수 있게 해줄 때에도 역시 메소드를 이용.
이런 메소드를 setter 메소드라고 하는데,
**데이터 변경이 되므로 반드시 필요한 경우에만 작성하고 신중하게 사용한다.**

— 이클립스는 getter, setter 메소드를 자동으로 만들어주는 기능을 가지고 있다.
따라서 필요하다면 모든 데이터는 private로 선언하고,
getter, setter 메소드는 버튼만 클릭해주면 된다.
