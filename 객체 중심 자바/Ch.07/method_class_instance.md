# CHAPTER 7. 메소드, 클래스, 인스턴스

# 메소드

- **함수** : 로직, 기능을 하나의 { }로 묶어서 한 덩어리로 만드는 방식
java에선 이를 **Method**라고 한다

- **함수는 3가지 형태로 구성**된다.
1. 메소드(함수)는 반드시 **자신을 구분할 수 있는 이름**을 가진다.
2. 메소드(함수)는 **동작하는 데 있어서 필요한 데이터**를 가질 수 있다.
3. 메소드(함수)는 **필요하다면 결과를 반환해주는 기능**도 있어야 한다.

- **명명 규칙**
1. 동작, 기능, 로직 관련 일이라 영어 '동사' 사용
2. 단어와 단어 사이는 대문자. 첫 글자는 대문자. (Class 파일이므로)
예) SumMachine

- **메소드 실행 시 필요한 데이터 : '파라미터' ( = 인자, 인수)**

- **메소드 이용 방식 2가지**
1. **Static** 라는 키워드와 함께 작성되는 **진짜 함수**와 비슷한 방법
2. **클래스, 객체** 이용해서 **동작하는 객체** 만드는 방법

- **메소드 만들기**
1. 메소드는 우선 **‘public void 메소드이름() {} ‘**을 작성하고 생각한다.
- public은 ‘누구나 이 기능을 사용할 수 있게’
- void는 ‘메소드를 호출한 쪽에서 결과를 얻을 수 없다는 표현’
- { } 안에는 필요한 데이터를 넣어준다. 
(괄호 안에는 이 기능을 실행하기 위해서 필요한 input이 무엇인지 얘기해준다
예를 들어, 필요한 데이터가 숫자인지, 숫자 몇 개인지...)

1. **메소드는 만들었으면 무조건 실행되게 한다.**
코드의 작은 부분이라도 반드시 실행해서 결과를 확인하도록 한다. → ‘디버깅’

- **main 메소드는 객체지향 프로그램과 무관하다.**
main 메소드는 어떤 로직을 실행 순서대로 만드는 게 중요하다
반면, 객체지향은 로직보다 객체에 중점을 둔다.

- **메소드를 만들면...**
1. 재사용이 가능하다. (메소드만 호출하면 해당 코드를 다시 쓸 수 있음)
2. 메소드가 데이터 입력받게 하면(메소드의 parameter - 메소드의 input 값에 다른 값을 줄 수 있게 하는 것) 매번 다른 데이터 처리 가능하다.
-> 재사용하려면 매번 다른 값을 줄 수 있게 한다.

- **파라미터의 타입 지정하기**
public void MakeSum(int startVal, int endVal)
-> 입력받는 두 데이터 중 첫 번째 들어온 데이터는 startVal에,
두 번째 들어온 데이터는 endVal

- **메소드에 선언하는 변수는 그 안에서만! → '지역 변수(local variable)'**

- **메소드 실행 결과**

— 리턴 타입 : 메소드 실행 후 독점 타입 결과 반환 선언하는 것 
                      (로직이나 기능을 수행한 후 어떤 형태로 결과 데이터가 나올지 정해져 있어야 하니까) 

— 리턴값 : 결과 데이터 / 연산자와 달리 결과 데이터 받기를 선택할 수 있다.

— 리턴 타입 유형
**void** -> 메소드를 실행해도 결과 데이터를 반환 X
**void 외 다른 타입** -> 메소드를 실행하면 반드시 그 타입의 결과 데이터 반환 O

예) public int makeSum(int start, int end){   // int 타입의 데이터 피드백

— return 키워드 이용해서 데이터 반환
(return은 실행을 여기까지 한다는 의미)

- **메소드 구성요소 3가지 : 메소드 이름 / 파라미터 / 리턴 타입**

1) 만들려는 ‘메소드의 이름’을 결정한다.

2) 메소드 실행에 필수적인 파라미터를 결정한다.

3) 메소드 실행 후 즉각적으로 피드백을 받을 것인지 결정한다.

# 객체지향의 객체(Object)

- **객체**

— 데이터를 알아서 보관, 관리 → 따라서 코드 호출할 때 편리하다.

— '데이터 - 로직(메소드)'이 서로 유기적으로 묶인 구조가 '객체'다.

- **클래스 : 데이터와 로직을 묶어둔 하나의 데이터.**
데이터와 로직을 묶어둔 덕분에 누구나 동일한 기능 사용하게 하나,
때에 따라서 다른 데이터를 보관할 수 있게 한다.

- **클래스**는 **복사본을 만들기 위한 원형(prototype)**과 같다.
따라서 다음과 같은 특징을 가진다.

— 각자 따로 보관하고 싶어하는 데이터 혹은 속성들
— 데이터에 관계없이 제공되는 같은 기능, 로직

→ 그리고 클래스의 복제본을 **'객체(Object, instance)'**라고 한다.

- 데이터 보관을 위한 장치 → '변수'
**객체마다 보관하는 변수**라는 의미에서 **'인스턴스 변수'**라고 한다.

- **객체지향 프로그래밍 순서**
1. 만들고 싶은 존재(Object)를 만들어 내기 위한 틀(Class)를 먼저 작성
2. 틀(Class) 선언 후, 필요 시 복사본(Instance 혹은 Object) 만들어 각자 필요에 맞게 사용
    
    → **인스턴스 = 객체 = 클래스(틀)의 복제본**
    

- 코드 : PigSave save = new PigSave();
(그림 그리기)

PigSave save1 = new Pigsave();

PigSave save2 = new Pigsave();

→ 이런 식으로 객체 여러 개 만들 수 있다.

- **변수 스타일 2가지**

**기본자료형** : 변수에 데이터가 직접 담김

**객체자료형** : 변수에 리모콘이 담음

- ‘**배열’**과 ‘클래스에서 생산된 **객체**’의 공통점 → 둘다 **여러 개의 데이터를 가질 수 있는 구조**

- **기본형 자료는 기본값을 가진다.**

byte, short, int, long : 숫자이므로 0

double, float : 소수이지만 데이터 없으므로 0.0

char : 아스키코드에 따라 ‘ ‘ (공백문자)

boolean : false

(예) int a ; 

// 변수 선언만 하고 따로 데이터 안 넣음. 따라서 기본값은 0
(int는 4byte이므로 32bit 상자, 각 bit에 0이 들어간 모양)

- **null**
1. **객체 자료형 변수**의 상자에 내용물 없을 때 사용
2. **제어문**에서 변수에 리모콘이 실제 객체를 가리키는데 사용

(예) if (a == null) 연산

a는 객체 자료형이고, a 안의 리모콘이 가리키는 객체가 있는지 없는지 따질 때 사용

- **NullPointerException 에러**

예) PigSave save = new PigSave( );

save = null ;    // 리모콘이 객체 가리키지 않게 함
save.deposit( );    // 리모콘이 가리키는 실체가 없으므로 동작 X

→ **해결법** : 문제가 일어난 부분에서 **‘ . ’ (점 - 리모콘 누르는 동작)**을 찾고 이용되는 변수 확인하기

- **객체 (object) : 메소드 기능 + 데이터의 결합체**

— ‘클래스’를 통해 필요한 만큼 만들고

— 메소드를 통해 데이터 저장 / 메소드는 데이터를 이용해서 제어함

— **‘인스턴스 변수’ → 객체의 데이터** 
(클래스의 복사본인 객체가 각각 가지는 데이터를 의미
메소드를 통해서 실행된 데이터를 보관하는 역할)

# 인스턴스 변수

예) public class PigSave {
public int total;
// **클래스 {} 안쪽에 선언한 변수** -> 각 객체마다 가지는 독립적인 데이터
// 값을 주지 않고 선언만 하는 이유? -> 클래스에서 나온 객체마다 다른 값을 가질 수도 있기 때문
// 따라서 인스턴스 변수는 필요하지 않으면 값을 줄 필요 X
// **인스턴스 변수의 용도 : 메소드를 통해서 실행된 결과 데이터를 보관**
// -> deposit 메소드를 통해 입금하면 total 데이터에 누적된다.

- **인스턴스 변수는 객체의 리모컨(레퍼런스)으로 사용할 수 있다.**

— 객체의 리모컨(레퍼런스)를 이용해서 가장 많이 하는 작업은,
**객체의 메소드를 실행**하는 것과, **객체의 데이터(속성)에 접근**하는 작업

— java에서 어떤 변수에 객체의 리모컨을 담아 두었다면
그 **변수와 '.'의 접근 방식**을 이용해서 어떤 동작을 시킬 수 있다.

예)
Scanner scanner = new Scanner([System.in](http://system.in/));
int a = scanner.nextInt();

→ 이처럼 '.'(dot)은 java 프로그래밍에서 어디엔가 접근하거나 메소드를 실행할 때 사용하는데,
그 대상은 2가지 **‘객체가 가진 메소드 / 객체가 가진 데이터’**

→ 즉, 객체의 리모컨(레퍼런스)를 이용해서 객체의 데이터와 객체의 메소드를 사용할 수 있다.

(그림19)

→ save라는 변수 안에는 리모콘이 담겨있고,
리모콘은 pigsave 객체, total 금액 데이터, deposit()메소드, withdraw()메소드를 접근할 수 있다

```jsx
public static void main(String[] args) {
      PigSave save = new PigSave();   
// 변수 save에 클래스에서 생산된 객체의 리모콘(레퍼런스)을 담는다

        save.deposit(100);      
// 변수에 리모콘을 담아두었다면 변수와 '.'의 접근 방식을 통해 어떤 동작을 시킬 수 있다.

        save.deposit(500);      
// 객체에 있는 deposit 메소드 기능 실행

        System.out.println(save.total);  
// 마찬가지로, 변수와 '.'을 통해 객체의 데이터에 접근하여 출력
```

- **정보 은닉** : 객체의 데이터는 함부로 공개하지 않는다.

— '.'을 이용하면 객체가 가진 로직과 데이터에 마음대로 접근할 수 있어 편하게 사용할 것 같지만,
실제로는 절대 이렇게 프로그램을 작성하면 안 된다.

— 객체의 데이터를 마음대로 직접 접근할 수 있다면...
메소드를 통해서 만들어진 데이터는 의미가 없게 되는 문제 발생 
(total 데이터의 값을 사용자 마음대로 조작할 수 있게 되는 문제 발생하기 때문.)

예) save.total = 10000;
→ 원래 total 값은 600원이었지만 이런 식으로 값을 주면 total은 10000원이 되어버림

→ 즉, 입금이라는 메소드를 통해서만 금액 데이터가 변경 가능해야 한다.

→ 객체에서 데이터는 어떤 메소드의 실행 결과를 누적해서 보존하는 경우가 많기 때문에 함부로 누구나 사용할 수 있게 하면 안된다.

- **객체의 데이터는 메소드를 통해 변경해야 한다.**
객체가 가진 기능(메소드)을 통해 데이터를 조정한다.
객체가 가지는 데이터는 호출한 쪽에서 데이터를 보관하지 않도록 하기 위한 장치다.

- **데이터가 외부에 공개되면 데이터의 순수성을 보장할 수 없게 된다.**
즉 밖으로 한번 나갔다 왔던 데이터는 누군가 조작했을 가능성도 있게 된다.
그래서 객체지향 프로그래밍에서 데이터는 감추어 두고 사용해야 한다고 주장.
이것을 **'캡슐화', '정보 은닉'**이라는 용어로 말한다.

- **접근 제한자 (Access Modifier)** : 외부에서 데이터에 접근하는 것을 막는다.
(= 객체 안의 데이터는 외부에서 보이지 않게 한다.)

→ **private : 외부에 공개하지 않는다.**
객체가 가진 데이터 앞에 private라는 단어를 사용하여 코드를 수정.

**예)**

```jsx
public class PigSave {
private int total // public 에서 변경

public class PigSaveTest {
public static void main(String[] args) {
Pigsave save = new Pigsave();
save.deposit(100);
save.deposit(500);
System.out.println(save.total);  // 컴파일 에러가 뜬다.
```

→ Pigsave 클래스 내 total 변수 앞에 private를 붙여주면,
PigSaveTest클래스에선 직접 접근이 안되어 컴파일 에러가 발생한다.

→ 클래스를 작성할 때 **인스턴스 변수를 private으로 작성한다는 것은,**
**클래스의 { }를 벗어나서는 접근할 수 없게 한다**는 뜻
클래스 { }의 바깥쪽 코드에서는 private으로 선언된 인스턴스 변수를 사용할 수 없다.

- **그럼 객체가 가진 데이터는 어떻게 알아내는가?**

— **객체의 데이터는 특별한 경우가 아니라면, 모두 private로 처리**한다.
— 외부에서 필요하다면 메소드를 이용해서 알 수 있도록 하는데,
이런 메소드를 보통 ‘**getter 메소드’**라고 한다.

— **객체가 가진 데이터를 접근하는 메소드**는 **getXXX** 같은 이름을 가진다.

**예)** total 데이터를 알려주는 getTotal() 메소드를 추가한 PigSave

(= PigSave에서 getTotal()이라는 메소드를 통해서 객체가 가진 데이터를 가져오게 함)

```
public class PigSave {
private int total;
// 인스턴스 변수 total을 private로 선언,
// PigSaveTest 클래스에서 직접 접근 불가능, getter메소드 이용해야 함
// public int total;   -> public으로 선언하면 PigSaveTest 클래스에서도 직접 접근 가능

public int getTotal() {	// total 값을 반환하는 메소드이므로, 리턴타입은 int
	return total;	//
}

public void deposit(int amount) {
	System.out.println("저금통 입금");
	total = total + amount
}

public void withdraw() {
	System.out.println("저금통 배를 땁니다.");
	total = 0;
}

```

```
public class PigSaveTest {
public static void main(String[] args) {
PigSave save = new PigSave();
save.deposit(100);
save.deposit(500);

int totalMoney = save.getTotal();
    // getTotal 메소드를 호출하여 반환된 total값을 Copy해서 totalMoney에 넣는다.
    // total값을 복사한 totalMoney를 이용하기 때문에 원본은 안전함.

System.out.println("총액 : " + totalMoney);
}
}
```

- **변수에 접근하는 대신 굳이 get 메소드를 쓰는 이유**

→ return한 결과를 받는 작업은 또다시 '복사'입니다.

예) int totalMoney = save.getTotal(); // total 변수의 값을 totalMoney 변수로 복사
→ PigSave 객체엔 total 데이터와 getTotal() 메소드가 있다.
save.getTotal()을 호출하면 PigSave 객체는 자신이 가진 total 데이터를 반환한다.
변수 할당은 '복사(Copy)' 개념으로, 메소드의 결과물(total 데이터)을 복사해서 변수에 담는다.
→ 따라서, 데이터에 직접 접근하지 않고 데이터를 복사하기 때문에 원본은 안전하다.

- **객체의 데이터는 반드시 안전하게!**

— 객체가 데이터를 가질 수 있는데, 이 데이터는 메소드를 통해서 접근하도록 하고, 가능하면 외부에 공개하지 않는다.

— 객체지향에선 대부분 데이터를 객체로 만들어서 보관한다.
이런 객체 안에 보관하는 데이터는 안전하게 보관해야 하므로, 외부에서 사용할 수 없게 private 키워드를 이용해서 처리한다.

— 데이터를 얻는 메소드는 getXXX()로 만들어준다.
메소드를 통해서 데이터를 얻으면 원본 데이터가 안전하게 보관된다.
이런 메소드를 일반적인 getter라고 한다. (데이터를 get하는 기능)

— **메소드를 통해서 데이터를 변경한다면 setter**
데이터를 바꿀 수 있게 해줄 때에도 역시 메소드를 이용.
이런 메소드를 setter 메소드라고 하는데,
**데이터 변경이 되므로 반드시 필요한 경우에만 작성하고 신중하게 사용한다.**

— 이클립스는 getter, setter 메소드를 자동으로 만들어주는 기능을 가지고 있다.
따라서 필요하다면 모든 데이터는 private로 선언하고,
getter, setter 메소드는 버튼만 클릭해주면 된다.


# 나만의 클래스, 객체를 만드는 순서

- 객체지향 프로그래밍을 배우는 작업을 어려워하는 가장 큰 이유는,
남들이 만든 소스를 보면 알 수 있지만, 자신이 어떻게 만들어야 하는지는 잘 모르기 때문.
따라서 자신만의 클래스를 만드는 순서와 기준을 명확히 잡아둬야 함.
이것을 보다 발전시키면 자신만의 분석과 설계 방식이 자리 잡게 된다.

- **클래스를 만드는 순서 -** 다음과 같이 작업하는 것이 일반적
1. 먼저 이름을 결정하고 클래스를 선언한다
2. 원하는 메소드를 선언해둔다.
3. 보관되어야 하는 데이터를 '인스턴스 변수'로 선언한다.
4. 메소드를 구현해 가면서 인스턴스 변수를 추가하거나 수정한다.
5. main 메소드를 이용해서 작업한 내용을 테스트한다.

- **클래스 이름**
1. 클래스의 이름은 주로 명사인 경우가 많음
2. 클래스의 이름은 주로 '역할', '직업'으로 구분되곤 함
(예) 요리사, 건축가, 관리자...
3. 클래스의 이름은 실생활의 이름을 쓰는 경우도 많다.
예) TV, 계산기, MP3 플레이어...

- **클래스를 선언할 때 가장 좋은 습관은 '하나의 그림'으로 표현해보는 것**

****(그림 21)

- **클래스가 아닌 객체라 생각하면서 원하는 메소드를 정한다.**
어떤 클래스를 만들어야 할지 결정했다면 다음은
이 클래스가 어떤 로직이나 기능을 가질 것인지 결정한다.
이는 문법적으로 메소드라는 것으로 형상화된다.

- 클래스를 표현해 둔 다이어그램 ‘아래쪽 영역’에
만들려고 하는 클래스가 가져야 하는 기능(메소드)을 작성

— 지금의 경우라면 '저금통'이 실제 있다고 가정하고 저금통이 가져야 하는 기능만을 생각
'저금통에 금액 데이터를 추가하는 기능'과 '금액 데이터를 초기화하는 기능'이 있다면
그 기능을 그림에 추가해준다.

(그림22)

- 객체가 가져야 하는 기능(메소드)를 고민할 때, 가능하면 **문장의 주어를 만들려고 하는 객체**로 시작한다.

예) "돼지 저금통은 xxx를 할 수 있다." 

→ 이렇게 문장을 만들어두면, 현재 만들려고 하는 클래스 안에 어떤 메소드가 선언되어야 할지 좀더 쉽게 결정할 수 있다.

- **로직이나 기능은 무조건 'public void'로 시작하는 메소드 선언하고 시작한다.**
1. 메소드 이름 결정하기
2. public void 이름() {} 코드 작성해두기
3. 메소드 파라미터 결정하기
4. 메소드의 리턴 타입 결정하기

- **메소드 작성할 때 파라미터를 먼저 판단한다.**

— 메소드를 실행하기 위한 필수 데이터인 파라미터(Parameter) 판단 기준

1. 메소드 실행할 때마다 매번 다르게 들어오는 데이터일 경우
2. 메소드 실행할 때 필수적인 데이터
→ 파라미터로 선언하기

- **즉각적으로 피드백하려면 '리턴'을 이용**

— 메소드 리턴 값 판단 기준

1. 메소드 실행 결과를 즉각적으로 피드백 -> void 대신 반환할 타입 명시
2. 메소드 실행 결과 보관할 때 메소드는 void -> 인스턴스 변수 활용해서 데이터 보관

# 지역변수

- **지역 변수(Local Variables)**

— 때로는 메소드 내부에서 변수를 사용할 때도 있다.
이런 변수를 '지역 변수'라고 하는데, 메소드의 안쪽에 선언되는 변수

— 지역 변수는 '임시', '일회성', '휘발성' 특성이 있는 변수
메소드 안에서 메모리상에 잠깐동안 만들어져 사용되는 변수를 의미하기 때문
변수의 선언이 메소드{} 안으로 국한되기 때문에 메소드 내에서만 효력이 있는 임시적인 변수

— 즉, 지역 변수는 메소드가 실행될 때, 호출할 때마다 잠깐 만들어져 사용되는 일회성 변수

- **지역 변수는 반드시 사용되기 전에 초기화되어야 한다.**

— 인스턴스 변수는 메소드 등을 통해서 객체가 살아있는 동안 스스로 진화하면서 발전할 수 있는 데이터다. 메소드의 실행 결과에 따라 영향을 받기도 하고 주기도 하기 때문.

— 반면 매번 메소드를 실행할 때마다 필요한 임시적인 데이터를 담는 변수는,
다음에 실행할 때에는 그 이전에 실행한 결과가 데이터로 남아있으면 안됨.

— 메소드가 동일한 상태에서 마찬가지로 실행되는 것을 보장하려면
메소드가 사용되는 임시 데이터도 동일한 상황이어야 하는 것.
따라서 메소드 안에 선언되는 변수는 사용하기 전에 초기화를 시켜준다.

# 인스턴스 변수

- 유지되는 객체의 데이터
어떤 메소드를 실행했는데 그 결과를 즉시 알려줄 필요가 없거나, 결과를 보관해 두는 것이 좋다고 판단했다면, 그것은 문법에서 '인스턴스 변수'로 선언된다.
- 인스턴스 변수와 지역 변수의 비교
(표)

— 인스턴스 변수의 원래 의미가 '로직에서 분리되어서 보관되는 데이터'라고 볼 수 있다.
— 그리고 이 데이터는,메소드라고 하는 기능을 통해서 만들어진 데이터.
— 따라서 인스턴스 변수는 메소드에서 만들어진 결과 데이터를 지속적으로 보관한다고 생각

예) PigSave 클래스에서 선언된 private int total -> 인스턴스 변수
deposit() 이란 동작을 했는데 즉각적인 피드백은 하지 않음.
그런데 이 데이터는 저금통의 원리처럼 계속해서 누적되는 데이터.
따라서 두 번 입금(deposit())하고, 그 결과를 누적해서 보관하기 위해 인스턴스 변수를 사용

- **인스턴스 변수 판단 기준**
1. 객체마다 보관해야 하는 데이터는 무조건 '인스턴스 변수'
2. 메소드의 실행 결과를 누적해서 보관하는 경우
3. 동일한 메소드를 여러 번 실행할 때마다 분기(if ~ else)의 기준이 되는 데이터
4. 메소드끼리 공유하는 데이터

- **인스턴스 변수와 메소드는 클래스 안에서 들여쓰기하는 레벨이 동일함.
(레벨이 동일하면 서로 영향을 줄 수 있다고 생각하면 된다.)**

- 객체 지향 프로그래밍에서 데이터의 보관은 개발자들에게 로직의 간소화를 가져옴
    
    +) 휴대전화로 메시지를 보낼 때 발신자 번호를 매번 일일이 지정하는 방식이 '함수형 언어'를 사용하는 방식이라면,
    객체지향 프로그래밍에서는 휴대전화가 자신의 번호를 저장하고 있기 때문에 그만큼 작업이 수월하게 처리되는 원리와 같다.
    

- **인스턴스 변수 = 객체의 상태, 속성**
클래스에 선언하는 인스턴스 변수는 주로 다음과 같은 특징이 있다.
1. **객체마다 데이터의 값이 다르게 유지된다.**
저금통이 여러 개라면 저금통마다 금액의 값이 다름
2. **메소드의 결과를 누적한다.**
입금하면 누적된 결과로 사용된다. 이 때문에 누적된 결과를 다른 곳에서 굳이 보관할 필요 x
3. **메소드의 판단기준이 될 수도 있다.**
비행기 게임처럼 폭탄의 수가 메소드를 실행할 때의 판단 기준이 된다.
4. **메소드끼리 공유하는 데이터**
저금통처럼 입금하면 금액 데이터가 증가하고, 출금하면 금액 데이터가 없어지는 경우

→ 이러한 이유로 인스턴스 변수는 '객체의 상태(State)' 혹은 '객체의 속성(Property)'라고 표현

## (실습) 복불복 기계 만들기

- 결정된 데이터가 ‘~들’인 경우 무조건 ‘배열’이나 ‘자료구조’
- 화면은 나중에 생각한다

# **객체의 데이터란?**

- 객체지향 프로그래밍

— 객체지향 프로그래밍 이전의 방식은, 로직과 로직 사이에 데이터가 흐르는 형태로 작성이 일반적

— 객체지향 프로그래밍에선, 
객체가 데이터 자체를 가지고 있기 때문에 데이터가 로직 사이를 흐르는 것이 아니라, 
객체와 객체 간의 의사소통을 통해서 어떤 작업이 일어나는 구조로 인식.

— 따라서 객체지향 프로그램을 구성하는 것은
어떤 객체들이 필요하고, 이 객체들과의 관계를 정해주는 것이 전부.

— 이 작업을 위해서 올바른 클래스를 만들어 내는 몇 가지 추가적인 노하우가 필요하다.

- '생성자(Constructor)'라는 표현법을 익히면,
클래스에서 객체를 만들어 낼 때 더 다양한 방식을 사용할 수 있게 된다.

— 객체(Object)는 결과적으로 데이터를 개별적으로 보관하는 장치
객체는 '데이터와 로직'으로 구성되고, 데이터는 보관되어야 하는 데이터를 의미.

— 데이터는 때로는 어떤 로직의 결과일 수도,
어떤 로직을 수행하기 위해 사용자가 입력한 파라미터일 수도 있으며,
어떤 로직을 수행하기 위해 적절한 판단기준이 되는 데이터일 수도 있다.

— 이 때문에 객체가 가진 데이터와 로직은
처음부터 어떻게 사용하게 할 것인가를 제어할 수 있는 방법도 제공된다.
이런 장치를 '생성자'라고 한다.

→ '생성자'를 이용하면 객체 생성 시 어떤 제약(반드시 필요한 데이터를 지정하거나)을 줄 수 있고,
객체가 생성되자마자 어떤 기능을 수행하게 할 수 있다.

- **객체는 데이터를 보관할 수 있는데, 만약 데이터가 필요하지 않으면?**

— 클래스에서 객체를 생산한다는 말은, 객체마다 다른 데이터를 가지게 하는 경우다.
— 개별적으로 보관할 필요가 없다면, 데이터를 보관하지 않는 단순 기능들은
굳이 클래스에서 객체를 생산하지 않아도 괜찮을 듯하다.

→ java에서도 이런 개념을 **static** 이란 키워드로 구현하고 있다. (뒤에서 설명)

**(예) Math.random()
→ 이 메소드는 new를 이용해서 객체(클래스의 복제, 인스턴스)를 생성하는 작업을 하지 않고 실행**

→ 그리고 **결과가 매번 다르게 나오는데,
즉,** Math.random()은 실행될 때 발생하는 데이터를 보관하지 않기 때문에
중복된 데이터가 나올 수 있다는 것을 알 수 있다.

- **객체란 '데이터의 묶음'**

— 결론적으로, 객체가 데이터를 개별적으로 보관하지 않는다면, 
굳이 어떤 데이터를 객체로 만들 필요 없다.

— 또한 클래스 선언 안에 여러 개의 인스턴스 변수를 선언할 수 있다는 것은
여러 개의 데이터를 각각 객체마다 보관하는 형태가 된다.

예) 성적에 대한 데이터 - '과목과 점수'라는 구성 요소로 이루어짐
→ 프로그래밍을 할 때, '과목과 점수'라는 두 가지 데이터는 분리되지 않는 하나의 의미를 가진 데이터임을 알아야 한다.
이를 '단위 데이터'라고 표현하기도 하는데,
이 데이터의 특징은 '도표'와 같은 형태로 표현할 수 있다는 것!

(그림 27)

"100점 받은 과목은?"
"국어 과목의 성적은?"

- 분리되면 의미 없는 데이터를 도표로 그려보자.
가로, 세로의 데이터, 그리고 도형의 종류(삼각형, 사각형) 데이터를 가지고 
도형의 넓이를 계산한다고 보자
이를 도표로 정리하면 아래와 같다.

(표)

각각의 도형마다 다른 데이터를 가지고 있고, 그 데이터는 떨어지면 의미가 없다.
즉 이 데이터의 가로 라인이 하나의 객체라고 보면 된다.
하나의 도형 객체는 '삼각형'이란 데이터와, 가로 100, 세로 250이란 데이터로 구성된 것

예) public class Shape {
private char type;
private int width;
private int height;
}
대충 이런 식이 될 것

**(예2)** 음식점에 먹은 음식의 값 계산한다면?
가격	수량
3000	  2
4000	  5

public class FoodPrice {
private int menuprice;
private int quantity;
}

→ 즉, **데이터들이 흩어지는 것을 막고자 객체로 묶어주고,** 
이를 위해서 **하나의 클래스를 선언**한다는 논리인 것.

# 데이터가 주인공인 클래스와 생성자(Constructor)

- **‘생성자’ 문법**

— 데이터를 중심에 두고 클래스를 설계하면 가끔 '객체가 특정 데이터를 반드시 가져야 하는 상황'이 발생한다. 
예) 도형의 경우, 넓이를 구하기 위해서 반드시 도형의 종류가 명시되어야 함
예2) 회원 가입 - 아이디, 패스워드가 필요한 것처럼

— 즉 데이터를 보관하기 위해서 객체를 만들 때, 반드시 어떠한 필수적인 데이터가 있어야만 객체로 만들고 싶은 경우 '생성자(Constructor)'라는 문법을 이용한다.

- **'생성자'라는 강제옵션**
1. 생성자는 클래스에서 **객체를 생성할 때만 사용**되며, **오직 new 뒤에 객체를 만들 때만 사용**한다.
2. 객체를 생성할 때 반드시 어떤 데이터를 넣지 않으면 객체를 생성할 수 없도록 한다.

→ **메소드**는 **객체가 할 수 있는 동작**을 의미하지만, **생성자**는 **객체의 생성 여부와 관계**가 있다.

## **기본 생성자(Default Constructor)라는 자동 코드**

- 기본 생성자는 Java 클래스 소스를 컴파일할 때, **컴파일러가 자동으로 만들어주는 생성자**
- 따로 만들지 않아도, **new라는 표현을 실행하면 기본 생성자를 통해서 객체가 생성된다.**

SampleObj obj = new SampleObj();
객체를 만들 때 가장 기본으로 사용하는 코드가 위와 같다.

클래스를 만들면 아래의 2가지 규칙을 지키는 함수가 자동으로 만들어지는데, 이를 기본 생성자(Default Constructor)라고 한다. -> 지우기?

1. 일반적인 메소드와 달리 리턴 타입에 대한 언급이 없다.
2. 메소드의 이름이 클래스의 이름과 같다.

## 사용자 정의 생성자(UserDefined Constructor)

- **사용자 정의 생성자(혹은 생성자 함수)**

— 기본 생성자와 달리 프로그래머가 직접 클래스를 만들 때 생성자라는 것을 정의할 때도 있는데, 이를 '사용자 정의 생성자'라고 함

— 개발자가 객체를 만들 때 꼭 이렇게 하고 싶다고 의사표현하는 것.
따라서 컴파일러는 기본 생성자를 포기하고, 개발자 의견대로 객체를 만들 수 있게 한다.

- **(예) 기본 생성자**

```jsx
public class SampleObj {
}	// 아무것도 선언하지 않은 SampleObj 클래스
```

— javap 명령어(역 컴파일러)를 이용해 SampleObj.class 파일을 조회하면...

```jsx
Compiled from "SampleObj.java"
public class SampleObj extends java.lang.Object { // 얘는 상속. 일단 넘어감
public SampleObj(); 
// -> 프로그램 만들 때 작성한 코드도 아닌데 클래스 파일이 가지고 있음 (기본 생성자)
}
```

  → 클래스를 만들면 위의 2가지 규칙을 지키는 함수가 자동으로 만들어진다.

1. 일반적인 메소드와 달리 **리턴 타입이 없다.**
2. **메소드의 이름이 클래스의 이름과 같다.**
    
    → 이러한 함수를 **기본 생성자**라고 한다.
    

- **(예) 사용자 정의 생성자를 추가한 SampleObj**

```
public class SampleObj {

public SampleObj(**int value**){ // 기존의 SampleObj 클래스에 사용자 정의 생성자를 추가함
}
```

— 이 코드를 기계어로 번역된 모습을 보면 다음과 같다.

```jsx
Compiled from "SampleObj.java"
public class SampleObj extends java.lang.Object {
public SampleObj(int);
}
```

    → **사용자 정의 생성자를 사용하면 컴파일러가 만드는 기본 생성자는 없어진다.**

    ****→ **사용자 정의 생성자**는 다음과 같은 **규칙**만 알면 만들어 낼 수 있다.

1. 메소드처럼 선언하지만 **메소드의 리턴 타입이 없다.**
2. **메소드의 이름이 클래스의 이름과 같다.**

## ‘기본 생성자’와 ‘사용자 정의 생성자’ 정리

- **기본 생성자** : 클래스를 만들면 객체를 생성할 수 있도록 컴파일러가 자동으로 만들어 줌.

- **사용자 정의 생성자 : 객체를 생성할 때 필수적인 데이터가 있도록 제약하는 것.**

— 예를 들어, 가격이 없는 메뉴는 없는 것처럼, 객체를 만들 때 반드시 특정 조건, 데이터를 만족해야 객체를 만들 수 있게 하려고 생성자 함수를 사용하는 것.

— 사용자 정의 생성자를 작성하면, **컴파일러 입장에선 개발자의 의도를 반영하고 기본 생성자 함수를 더는 작성하지 않음.**

— 개발자가 원하는 대로만 객체를 생성할 수 있게 함.
이런 의미에서 사용자 정의 생성자 함수는 객체를 생성하는 데 제약 조건처럼 동작한다.

- **비교 정리**

public SampleObj {         

// 클래스만 선언하면 기본생성자가 만들어짐

// 역컴파일러 : public SampleObj()   → 클래스에 쓰지 않아도 저절로 생긴 기본 생성자

public SampleObj(**int value**){         

// 기존의 SampleObj 클래스에 사용자 정의 생성자를 추가함

// 역컴파일러 : public SampleObj(int)    → 사용자 정의 생성자

# 생성자와 this라는 키워드

- **this를 해석하는 가장 편리한 해석은 self**

(예)

```java
public Shape (char t, int w, int h) {    // 사용자 정의 생성자에 파라미터를 세 개 던지고
		type = t;
		width = w;
		height = h;
// 객체의 데이터인 type, width, height의 값으로 지정함
}
```

  → 이 코드는 다음과 같이 사용 가능하다.

```java
public Shape (char t, int w, int h) {
		this.type = t;
		this.width = w;
		this.height = h;
}
```

→ ‘.’ 표시는 리모콘을 눌러서 객체를 동작시킬 때 주로 사용함.

즉, 위의 this는 **‘현재 이 코드를 실행하는 객체’**를 말한다.

(해석하면, 파라미터로 들어온 width, height라는 변수의 값을 현재 이 코드를 실행하는 객체의 인스턴스 변수로 삼겠다는 뜻)

- **현재 객체의 데이터나 메소드에 접근할 때 사용하는 this**

실무에서는 생성자를 작성할 때 다음과 같이 만들어 주는 것이 관례다.

```java
public Shape (char type, int width, int height) {
	this.type = type;
	this.width = width;
	this.height = height;
}
```

→ 사용자 정의 생성자에 **파라미터의 이름**을 일부러 **객체의 인스턴스 변수의 이름**과 **동일하게 작성**

→ 이는 **‘가독성’** 때문에 하는 작업. 
파라미터가 많으면, 입력한 파라미터가 객체 안에서 어떻게 사용될지 알 수 없는 일이 발생하기 때문
따라서 파라미터를 아예 데이터의 이름과 통일시켜 버린다.
이렇게 되면 width로 던지는 파라미터가, 현재 객체의 width 데이터가 될 것임이 잘 보이기 때문.

+) 성능으로 따지면 this.width와 같은 방식은 오히려 성능을 저해하지만,
”빠른 코드보다 쉬운 코드가 더 낫다”는 격언대로 this를 이용해주자.

- **사용자 정의 생성자는 여러 개 만들 수 있다. (= 객체를 생산하는 방식이 여러 가지라는 뜻)**

— 사용자 정의 생성자가 세 개라면 세 가지 방식으로 객체를 만들 수 있다.

**예)** 10개의 데이터가 있는데, 그 중 5개만 반드시 필요하고 나머지는 필요 없거나 기본적인 어떤 값을 가지는 경우라면?

→ 사용자 정의 생성자는 **객체를 만드는 옵션**이기 때문에, 이런 상황을 대비해 여러 개를 작성할 수 있다.

```
public class FoodPrice {

private int menuPrice;
private int quantity;	// 인스턴스 변수 선언
public FoodPrice(int menuPrice) {
// 사용자 정의 생성자 (리턴타입 없음+클래스 이름과 같음)

	this.menuPrice = menuPrice;
	this.quantity = 1;
}

public FoodPrice(int menuPrice, int quantity) {
// 사용자 정의 생성자 2
	this.menuPrice = menuPrice;
	this.quantity = quantity;
}

public int getTotalPrice() {
	return menuPrice * quantity;
}

```

→ 거의 비슷한 코드가 두 번 사용된 생성자

사용자 정의 생성자 함수를 여러 개 작성할 때 고려해야할 것
**'중복적인 코드가 발생한다'**

- **this() -> 또 다른 생성자 호출**
this 키워드의 또 다른 용도는 다른 사용자 정의 생성자를 호출하는 것
    
    ```java
    public FoodPrice(int menuPrice) {
    this(menuPrice,1);	
    // **this()는 또 다른 생성자를 호출할 때 사용**
    // **생성자 중 파라미터 두 개 받는 생성자를 찾아 실행하라는 의미**
    }
    
    public FoodPrice(int menuPrice, int quantity) {
    this.menuPrice = menuPrice;
    this.quantity = quantity;
    }
    ```
    

→ 생성자가 하나의 클래스에 여러 개 정의되는 경우 위의 방식을 이용해서 중복 코드를 최소화

# 사용자 정의 생성자와 오버로딩(Overloading)

- **오버로딩 : 동일한 소스 내에서 이름이 같은 메소드나 사용자 정의 함수가 여러 개인 모습을 의미**

사용자 정의 생성자 경우, **모두 클래스의 이름과 같다**.
다만, 그 안의 **파라미터의 값이 경우에 따라 다르게 작성됨.**
객체지향에서는 **오버로딩(Overloading)**이라는 용어로 이런 코드를 설명

- **오버로딩은 다음과 같은 규칙을 따른다**.
1. 호출하는 이름은 같지만, 파라미터들은 다르다.
2. 파라미터 개수가 같다면 파라미터들의 타입이 다르다.
3. 리턴 타입은 다를 수 있다(생성자의 경우, 리턴타입이 없으므로 신경 쓰지 않아도 됨)

- **오버로딩은 Java에서 생성자와 메소드에서 사용 가능
—** 가장 많이 쓰이는 곳은 '생성자'
— 메소드의 경우 동일한 기능의 메소드이지만 경우에 따라 다른 파라미터들로 처리해야 하는 경우에 적용된다.

# 객체가 만들어진 직후 어떤 메소드를 실행할 때도 
‘생성자’

- **생성자 가장 빈번하게 사용되는 경우 : '객체가 만들어진 직후 어떤 메소드를 실행하고 싶을 때'**

클래스에서 객체가 만들어지면서 처리되는 메소드가 있다면, 
**이런 메소드들은 외부에서 호출되기 전에 생성자에 호출될 수 있다.**

**예1) 객체가 생성될 때 어떤 메소드를 호출해야 하는 상황**
— 클래스 안에 인터넷과의 연결이 필요하다면?
객체를 생성해서 동작하기 전에 반드시 인터넷 가능 여부가 확인되어야 한다면
다음과 같은 가상의 코드를 생각해볼 수 있다.

```
public class InternetData {
private String domain;	// 인스턴스 변수

public InternetData(String domain){	// 사용자 정의 생성자
	this.domain = domain;
}

public void checkInternet() {		// 메소드
	System.out.println("인터넷부터 확인합니다.");
}
}
```

→ 위와 같이 코드를 짜면, 클래스에서 객체를 만드는 사람은, 다른 메소드를 실행시키기 전에 반드시 checkInternet() 메소드를 실행해서 인터넷 접속이 가능한지 확인하는 코드가 들어가야 함

**예2) 생성자에서 처리되지 않는 경우**

```java
public static void main(String[] args) {
InternetData obj = new InternetData("[http://www.google.com](http://www.google.com/)");
// 인터넷 확인
obj.checkInternet();
// 나머지 작업
}
```

→ 그런데 객체가 생성되면서 인터넷이 체크되도록 수정하면
사용자가 객체를 생성하여 사용할 때 인터넷이 체크되므로 별도의 확인 작업이 필요없다.

**예3) 생성자에서 객체 생성시 필요한 메소드를 바로 실행**

```
public class InternetData{
		private String domain;

public InternetData(String domain){
	this.domain = domain;
	checkInternet();
}

private void checkInternet() {
	System.out.println("인터넷부터 확인합니다.");
}
}
```

→ 수정된 코드는 생성자 내에서 바로 checkInternet() 메소드 실행.

이러면 외부에서는 매번 객체를 만들 때마다 checkInternet() 메소드를 실행해야 하는 불편함을 없앨 수 있다.

또한 checkInternet() 메소드 역시 public에서 private로 외부에서 호출할 필요가 없어지면서 접근 제한이 변경됨.

- **정리 : 생성자 기능을 크게 두 가지로 구분한다.**
1. **객체 생성 시 절대적으로 필요한 데이터를 넣도록 하는 강제성**
2. **객체가 생성되면 자동으로 어떤 메소드를 호출하는 기능**
